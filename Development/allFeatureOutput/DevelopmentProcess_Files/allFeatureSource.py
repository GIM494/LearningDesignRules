#### NOTE 1: MUST USE PYTHON3 TO RUN FILE
#### NOTE 2: MUST USE WITH JAVA SOURCE FILES THAT HAVE BEEN PROCESSED BY srcML
​
#### INPUT: There is not input for running the file, but once the file is running,
####        the user will want to execute
####             createFunctionDatabase(filename, [id_no])
####        in order to generate the actual database.
#### OUTPUT: Output is only generated after executing the function above. Output
####        is two files: filedata_functions.txt containing the database of
####        transactions (rows) and their features by id_no ("columns"), and
####        file_METAdata_functions.txt containing the features by id_no and
####        their descriptions.
​
##### NOTE MODIFIED OUTPUT ONCE SUB-SCRIPTS HAVE BEEN DEVELOPED AND RUN #######
###############################################################################
​
​
​
## The interface we import allows us to parse XML source code.
## The basic idea of this implementation is that there is
# a simple, flexible type of container object called Element that
# stores hierarchal data structures (like XML structures). The
# ElementTree type has code that can load an XML file as a tree
# composed of Element objects.
## xml.etree.ElementTree is a C implementation of the API.
import xml.etree.ElementTree as ET
import dataAttribute_class as DA
​
# This has the nameSpaces for srcML code; additional namespaces
# may need to be added for languages other than java
nameSpace = { 'src': 'http://www.srcML.org/srcML/src'}
​
# This is a global list of attributes and constitutes the 'header'
# of the database.
allAttributes = []
​
# We also have this array variable, which is reset after each iteration of
# the function (for fnc in...) inner loop. This array contains the attributes
# that are found for the function and is reset after each iteration. Each version
# of the array is what becomes a single row in the output database.
fncAttributes = []
​
# NOTE: In Java functions cannot be defined/declared outside of classes;
# Additionally, unlike c++, the function declaration cannot be separate
# from the function defintion, so we simply look for the 'function' tag.
​
# INPUT: file name (already in srcml format), ID number (default = 1)
​
def createFunctionDatabase(filename, id_no=1):
	# Import data for reading
	tree = ET.parse(filename)
	root = tree.getroot()
​
	# Empty file contents if not already empty
	open("filedata_functions.txt", "w").close()
​
	# NOTE: This database is generated by first finding all classes (subclasses,
	# inner classes, outer classes), then finding all top-level functions in each
	# class. We do so to avoid generating duplicate functions/transactions, but
	# one consideration to note is that we may want to know that a function is in
	# a class that is a subclass of X, or that it is in a class that extends Y, etc.
​
	for cl in root.findall(".//src:class", nameSpace):
		# find anonymous classes:
		#clName = cl.find("src:name", nameSpace)
		#print(clName.text)
		for fnc in cl.findall("src:block/src:function", nameSpace):
			# for debugging:
			#fncName = fnc.find("src:name", nameSpace)
			#print(fncName.text)
​
			# Combine searches for (1) constructor call and (2) function call in return
			# statement (combined for efficiency).
			fncReturnInfo = fnc.find(".//src:block/src:return/src:expr", nameSpace)
			# Function return info exists: search for constructor or call
			if fncReturnInfo is not None:
				# (1) Calls constructor (expandable)
				constructorCall = fncReturnInfo.find("src:operator", nameSpace)
				if constructorCall is not None and constructorCall.text == "new":

					# Check whether attribute has been seen globally
					foundAttr = next((x for x in allAttributes if x.name == "calls constructor"), None)
					# Attribute not already seen globally
					if foundAttr is None:
						allAttributes.append(DA.DataAttribute("calls constructor", id_no, canExpand=True))
						fncAttributes.append(id_no)
						id_no += 1
					# Attribute seen globally
					else:
						fncAttributes.append(foundAttr.id)
				# (2) Returns output from function call (expandable)
				retOutputFromFncCall = fncReturnInfo.find("src:call", nameSpace)
				if retOutputFromFncCall is not None:
					# Check whether attribute has been seen globally
					foundAttr = next((x for x in allAttributes if x.name == "returns output from function call"), None)
					# Attribute not already seen globally
					if foundAttr is None:
						allAttributes.append(DA.DataAttribute("returns output from function call", id_no, canExpand=True))
						fncAttributes.append(id_no)
						id_no += 1
					# Attribute seen globally
					else:
						fncAttributes.append(foundAttr.id)
​
​
			# Has parameters (expandable)
			hasParams = fnc.find("src:parameter_list/src:parameter", nameSpace)
			if hasParams is not None:
				# Check whether attribute has been seen globally
				foundAttr = next((x for x in allAttributes if x.name == "has parameters"), None)
				# Attribute not already seen globally
				if foundAttr is None:
					allAttributes.append(DA.DataAttribute("has parameters", id_no, canExpand=True))
					fncAttributes.append(id_no)
					id_no += 1
				# Attribute seen globally
				else:
					fncAttributes.append(foundAttr.id)
​
​
			# Modifies member variable (expandable)
			modifiesMemberVar = fnc.findall("src:block/src:expr_stmt/src:expr", nameSpace)
			if modifiesMemberVar is not None:
				for mod in modifiesMemberVar:
					name = mod.find("src:name/src:name", nameSpace)
					op =  mod.find("src:operator", nameSpace)
					call = mod.find("src:call/src:name/src:name", nameSpace)
					if (((name is not None) and (name.text == "this")) and ((op is not None) and (op.text == "="))
						or ((call is not None) and (call.text == "this"))):
						# Check whether attribute has been seen globally
						foundAttr = next((x for x in allAttributes if x.name == "modifies member variable"), None)
						# Attribute not already seen globally
						if foundAttr is None:
							allAttributes.append(DA.DataAttribute("modifies member variable", id_no, canExpand=True))
							fncAttributes.append(id_no)
							id_no += 1
						# Attribute seen globally
						else:
							fncAttributes.append(foundAttr.id)
						break
​
​
			# Combine searches for (1) is void and (2) returns type ... (combined for efficiency).
			returnType = fnc.find("src:type/src:name", nameSpace)
			if returnType is not None:
				# Check for list: when the return type is a list, the function's type
        		# nests the list name with other arguments.
				if returnType.text is None:
					returnType = returnType.find("src:name", nameSpace)
        		# (1) Is void
				if returnType.text == "void":
					# Check whether attribute has been seen globally
					foundAttr = next((x for x in allAttributes if x.name == "is void"), None)
					# Attribute not already seen globally
					if foundAttr is None:
						allAttributes.append(DA.DataAttribute("is void", id_no))
						fncAttributes.append(id_no)
						id_no += 1
					# Attribute seen globally
					else:
						fncAttributes.append(foundAttr.id)

				# (2) Returns type ...
				else:
					retAttr = "return type " + returnType.text
					# Check whether attribute has been seen globally
					foundAttr = next((x for x in allAttributes if x.name == retAttr), None)
					# Attribute not already seen globally
					if foundAttr is None:
						allAttributes.append(DA.DataAttribute(retAttr, id_no))
						fncAttributes.append(id_no)
						id_no += 1
					# Attribute seen globally
					else:
						fncAttributes.append(foundAttr.id)
​
			# Has annotation
			hasAnnot = fnc.find("src:annotation", nameSpace)
			if hasAnnot is not None:
				# Check whether attribute has been seen globally
				foundAttr = next((x for x in allAttributes if x.name == "has annotation"), None)
				# Attribute not already seen globally
				if foundAttr is None:
					allAttributes.append(DA.DataAttribute("has annotation", id_no))
					fncAttributes.append(id_no)
					id_no += 1
				# Attribute seen globally
				else:
					fncAttributes.append(foundAttr.id)
​
			# in class ...
			inClassName = cl.find("src:name", nameSpace)
			# Check that class name exists (i.e. not anonymous)
			if inClassName is not None:
				clAttr = "in class " + inClassName.text
				# Check whether attribute has been seen globally
				foundAttr = next((x for x in allAttributes if x.name == clAttr), None)
				# Attribute not already seen globally
				if foundAttr is None:
					allAttributes.append(DA.DataAttribute(clAttr, id_no))
					fncAttributes.append(id_no)
					id_no += 1
				# Attribute seen globally
				else:
					fncAttributes.append(foundAttr.id)
​
​
			# Sort attribute values in ascending order
			fncAttributes.sort()
​
    		# Output attributes found to file that will contain database
​
    		# This is the file we will be outputting to; we will append to this file
    		# that way we can write to other files and open this one up later and not
    		# lose any progress; the "+" sign indicates that we will create a new file if
    		# one has not been created before
			file = open("filedata_functions.txt","a+")
​
			# for debugging:
			#file.write(fncName.text + " | ")
​
			file.write(' '.join(str(attr) for attr in fncAttributes))
			file.write('\n')
​
    		# Close the file once we are done outputting information to it
			file.close()
​
			# Reset array containing function attributes for next iteration
			fncAttributes.clear()
​
	# Open file to output all the metadata
	file = open("file_METAdata_functions.txt", "w")
​
	for attr in allAttributes:
		file.write(str(attr.id) + " " + attr.name + "\n")
​
	# Close the file once we are done outputting information to it
	file.close()
​
###############################################################################
###############################################################################
###############################################################################

import xml.etree.ElementTree as ET
import dataAttribute_class as DA

globalAttributes = []
createdFiles = []
nameSpace = { 'src': 'http://www.srcML.org/srcML/src'}

def createSubclassDatabases(id_no, filename):

    #print(filename + " in createData_subclasses")

    # This is how we import data if we are reading the file from
    # the disk
    # Note: change the name of the file to match the name of the srcML file
    # we will parse
    tree = ET.parse(filename)
    root = tree.getroot()

    for cl in root.findall(".//src:class", nameSpace):

        nomer_check1 = (cl.find("src:name", nameSpace))
        if nomer_check1 is not None:
            nomer_check2 = (cl.find("src:name", nameSpace)).text
            if nomer_check2 is not None:
                className = "class " + nomer_check2
                #print(className)
            else:
                continue

        #print("<------->")

        #If this class doesn't have any sub-classes, go to the next
        # class we found to see if it has subclasses
        subclassCandidate = cl.findall(".//src:block/src:class", nameSpace)
        if subclassCandidate is None:
            continue
        else:
            #print(className)
            # contains the types of the member variables in the superclass names
            superclass_memberVars = []
            paramList = cl.findall(".//src:decl_stmt/src:decl/src:type/src:name", nameSpace)
            exclusionVars = cl.findall(".//src:class/src:block/src:class/src:decl_stmt/src:decl/src:type/src:name", nameSpace)
            if len(paramList) > 0:
                for param in paramList:
                    if param not in exclusionVars:
                    #print("|-> " + str(param))
                    #for p in param:
                        #print("--> " + str(p))
                        if param.text is not None:
                            memberVarType = "member variable of type " + str(param.text)
                            if memberVarType not in superclass_memberVars:
                                superclass_memberVars.append(memberVarType)

            for subCL in subclassCandidate:
                outputData = filename[0:len(filename)-4] + "_subclassData.txt"
                id_no = outputSubclassProperties(id_no, subCL, superclass_memberVars, outputData)


    outputMetadata = filename[0:len(filename)-4] + "_MetaData.txt"
    open(outputMetadata, "w").close()
    file = open(outputMetadata, "a+")
    #print(len(globalAttributes))
    for attr in globalAttributes:
        file.write(attr.infoToFile())

    file.close()

    return [id_no, createdFiles]

def outputSubclassProperties(id_no, subCL, superclass_memberVars, fileTitle):

    print(*superclass_memberVars, sep = " ")
    #fileTitle = (subCL.find("src:name", nameSpace)).text + "_subclassData.txt"

    print(subCL.find("src:name", nameSpace).text)
    print("<------->")
    print("<------->")

    attributes = []
    name = ""

    # Output all annotations on subclasses
    print("Class Annotations:")
    clsAnnotCandidate = subCL.findall("src:annotation", nameSpace)
    if clsAnnotCandidate is not None:

        for clsAnnot in clsAnnotCandidate:

            clsAnnotName = "@" + (clsAnnot.find('src:name', nameSpace)).text + " on subclass"

            foundAttribute = next((x for x in globalAttributes if x.name == clsAnnotName), None)
            if foundAttribute is None:
                globalAttributes.append(DA.DataAttribute(clsAnnotName, id_no))
                attributes.append(id_no)
                print(" |--> Appended 1a")
                globalAttributes[-1].printCharacteristics()
                id_no += 1
            elif foundAttribute.id not in attributes:
                attributes.append(foundAttribute.id)
                print(" |--> Appended 1b")
                foundAttribute.printCharacteristics()

    outputString = " ".join(str(attr) for attr in attributes) + "\n"
    print("output: " + outputString)

    print("<------------>")

    # See if the member variables of the subclass share the same member
    # variable; "member X found in class and subclass"
    print("Shared Member Vars:")

    memberVarList = subCL.findall(".//src:decl_stmt/src:decl/src:type/src:name", nameSpace)
    if len(memberVarList) > 0:
        for p in memberVarList:
            memberVarType = "member variable of type " + p.text
            if memberVarType in superclass_memberVars:
                name = "shares with superclass member variable of type " + p.text
                foundAttribute = next((x for x in globalAttributes if x.name == name), None)
                if foundAttribute is None:
                    globalAttributes.append(DA.DataAttribute(name,id_no))
                    attributes.append(id_no)
                    print(" |--> Appended 2a")
                    globalAttributes[-1].printCharacteristics()
                    id_no += 1
                elif foundAttribute.id not in attributes:
                    attributes.append(foundAttribute.id)
                    print(" |--> Appended 2b")
                    foundAttribute.printCharacteristics()

            # Output all member variables that are not found in both
            else:
                name = "member variable of type " + p.text + " only in subclass"
                foundAttribute = next((x for x in globalAttributes if x.name == name), None)
                if foundAttribute is None:
                    globalAttributes.append(DA.DataAttribute(name,id_no))
                    attributes.append(id_no)
                    print(" |--> Appended 3a")
                    globalAttributes[-1].printCharacteristics()
                    id_no += 1
                elif foundAttribute.id not in attributes:
                    attributes.append(foundAttribute.id)
                    print(" |--> Appended 3b")
                    foundAttribute.printCharacteristics()

            #print(p.text)
            #memberVarType = "member variable of type " + p.text
            #if memberVarType not in superclass_memberVars:
                #globalAttributes.append(memberVarType)
                #print(" |--> Appended")

    outputString = " ".join(str(attr) for attr in attributes) + "\n"
    print("output: " + outputString)

    print("<------------>")


    # Output all functions defined in subclasses
    for fnc in subCL.findall(".//src:function", nameSpace):
        print("Subclass function defs:")
        fncName = (fnc.find("src:name", nameSpace)).text + "()"

        foundAttribute = next((x for x in globalAttributes if x.name == fncName), None)
        if foundAttribute is None:
            globalAttributes.append(DA.DataAttribute(fncName, id_no))
            attributes.append(id_no)
            print(" |--> Appended 4a")
            globalAttributes[-1].printCharacteristics()
            id_no += 1
        elif foundAttribute.id not in attributes:
            attributes.append(foundAttribute.id)
            print(" |--> Appended 4b")
            foundAttribute.printCharacteristics()

        outputString = " ".join(str(attr) for attr in attributes) + "\n"
        print("output: " + outputString)

        print("<------------>")

        print("Subclass annotations: ")
        # Output all annotations on functions in subclasses
        fncAnnotCandidate = fnc.find("src:annotation", nameSpace)
        if fncAnnotCandidate is not None:
            fncAnnotName = "@" + (fncAnnotCandidate.find('src:name', nameSpace)).text + " on function"

            foundAttribute = next((x for x in globalAttributes if x.name == fncAnnotName), None)
            if foundAttribute is None:
                globalAttributes.append(DA.DataAttribute(fncAnnotName, id_no))
                attributes.append(id_no)
                print(" |--> Appended 5a")
                globalAttributes[-1].printCharacteristics()
                id_no += 1
            elif foundAttribute.id not in attributes:
                attributes.append(foundAttribute.id)
                print(" |--> Appended 5b")
                foundAttribute.printCharacteristics()

        outputString = " ".join(str(attr) for attr in attributes) + "\n"
        print("output: " + outputString)

        print("<------------>")


    # Output list of attributes for this subclass to a file
    file = open(fileTitle, "a")
    outputString = " "
    outputString = " ".join(str(attr) for attr in attributes) + "\n"
    print("output: " + outputString)
    file.write(outputString)
    file.close()

    attributes.clear()


    createdFiles.append(fileTitle)
    return id_no
