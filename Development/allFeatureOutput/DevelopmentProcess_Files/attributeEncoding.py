import xml.etree.ElementTree as ET


## Comment the following code out before testing with other file ##
classFilename =
classTree = ET.parse(classFilename)
classRoot = classTree.getroot()
####################################################################


attributeList = {}
id_no = 1

def generateAttributes(classRoot):

    # Output all annotations on class
    # print("Class Annotations:")
    clsAnnotCandidate = classRoot.findall("src:annotation", nameSpace)
    if clsAnnotCandidate is not None:

        for clsAnnot in clsAnnotCandidate:

            clsAnnotName = "@" + (clsAnnot.find('src:name', nameSpace)).text + " on class"

            if classAnnotName not in attributeList:
                attributeList[classAnnotName] = id_no
                id_no += 1

    # What kind of constructor the class has
    constructor = classRoot.find("src:block/src:constructor", nameSpace)
    params = []
    if constructor != None:
        paramsList = constructor.findall("src:parameter_list/src:parameter/src:decl/src:name", nameSpace)
        for p in paramsList:
            params.append(p.text)
    # If this class doesn't have a constructor OR only has a constructor
    # with no arguments then print a message stating as much
    if constructor != None and len(params) != 0:
        name = "class has constructor with parameters"
        if paramConstructor not in attributeList:
            attributeList[name] = id_no
            id_no += 1
    else:
        name = "class has constructor with no parameters"
        if noArgsConstructor not in attributeList:
            attributeList[name] = id_no
            id_no += 1

    # Output all member variable types
    memberVarTypeList = classRoot.findall(".//src:decl_stmt/src:decl/src:type/src:name", nameSpace)
    if len(memberVarTypeList) > 0:
        for p in memberVarTypeList:
            memberVarType = "class has member field of type " + p.text

            if memberVarType not in attributeList:
                attributeList[memberVarType] = id_no
                id_no += 1

    # Output all member fields
    memberVarList = classRoot.findall(".//src:decl_stmt/src:decl/src:type/src:name/src:name", nameSpace)
    if len(memberVarList) > 0:
        for p in memberVarList:
            memberVarName = "class has member field called " + p.text

            if memberVarName not in attributeList:
                attributeList[memberVarName] = id_no
                id_no += 1

    # DOUBLE CHECK THIS ONE
    # Output all member fields of a particular type
    memberVarTypeList = classRoot.findall(".//src:decl_stmt/src:decl/src:type/src:name", nameSpace)
    if len(memberVarTypeList) > 0:
        for p in memberVarTypeList:
            memberVarName = (p.find("src:name", nameSpace)).text
            memberVarType = "class has member field" + memberVarName + " of type " + p.text

            if memberVarType not in attributeList:
                attributeList[memberVarType] = id_no
                id_no += 1


    # What a class extends
    classExtends = classRoot.find('.//src:extends', nameSpace)
    if classExtends is not None:
        classExtendsName = "class extends class " + (classExtends.find('src:name', nameSpace)).text

        if classExtendsName not in attributeList:
            attributeList[classExtendsName] = id_no
            id_no += 1

    # Get class visibility specifier
    clSpecificity = classRoot.find("src:specifier", nameSpace)
    # If the class does not have an explicit visibility specifier
    # then it is public by default
    if clSpecificity == None:
        clSpecificity = "public"
    else:
        clSpecificity = clSpecificity.text

    if clSpecificity not in attributeList:
        classSpecName = "is " + clSpecificity + " class"
        attributeList[classSpecName] = id_no
        id_no += 1


    # NOTE: This database is generated by first finding all classes (subclasses,
	# inner classes, outer classes), then finding all top-level functions in each
	# class. We do so to avoid generating duplicate functions/transactions, but
	# one consideration to note is that we may want to know that a function is in
	# a class that is a subclass of X, or that it is in a class that extends Y, etc.
​
	for fnc in classRoot.findall("src:block/src:function", nameSpace):

        # Get visibility specifiers for the functions
        fncSpec = fnc.find("src:specifier", nameSpace)
        fncSpecType = ""

        # If the function didn't have a visibility specifier, then we
        # default to the class' visibility
        if fncSpec is None:
            fncSpecType = clSpecificity

        # Otherwise, we were able to find a visibility specifier for the
        # function, so we use that
        else:
            fncSpecType = fncSpec.text

        fncName = "has " + fncSpecType + " " + (fnc.find("src:name", nameSpace)).text + "() function"

        if fncName not in attributeList:
            attributeList[fncName]= id_no
            id_no += 1
​
		# Combine searches for (1) constructor call and (2) function call in return
		# statement (combined for efficiency).
		fncReturnInfo = fnc.find(".//src:block/src:return/src:expr", nameSpace)
		# Function return info exists: search for constructor or call
		if fncReturnInfo is not None:
			# (1) Calls constructor (expandable)
			constructorCall = fncReturnInfo.find("src:operator", nameSpace)
			if constructorCall is not None and constructorCall.text == "new":
                name = fncName.text + "() function calls constructor in return statement"
                # Check whether attribute has been seen globally
                if name not in attributeList:
                    attributeList[name] = id_no
                    id_no += 1

			# (2) Returns output from function call (expandable)
			retOutputFromFncCall = fncReturnInfo.find("src:call", nameSpace)
			if retOutputFromFncCall is not None:
                name = fncName.text +  "() function returns output from function call"

                #### ALSO SEE IF WE CAN GET THE EXACT TYPE FOR THIS ####
				if name not in attributeList:
					attributeList[name] = id_no
					id_no += 1

​
		# Has parameters (expandable)
		hasParams = fnc.find("src:parameter_list/src:parameter", nameSpace)
		if hasParams is not None:
            name = fncName.text + "() function has parameters"
            # Check whether attribute has been seen globally
            if name not in attributeList:
			    attributeList[name] = id_no
				id_no += 1
​
		# Modifies member variable with specific name
		modifiesMemberVar = fnc.findall("src:block/src:expr_stmt/src:expr", nameSpace)
		if modifiesMemberVar is not None:
			for mod in modifiesMemberVar:
				name = mod.find("src:name/src:name", nameSpace)
				op =  mod.find("src:operator", nameSpace)
				call = mod.find("src:call/src:name/src:name", nameSpace)
				if (((name is not None) and (name.text == "this")) and ((op is not None) and (op.text == "="))
					or ((call is not None) and (call.text == "this"))):
                    attrName = fncName.text + "() function modifies member variable" + name
					# Check whether attribute has been seen globally
                    if attrName not in attributeList:
				        attributeList[name] = id_no
						id_no += 1
​
​
		# Combine searches for (1) is void and (2) returns type ... (combined for efficiency).
		returnType = fnc.find("src:type/src:name", nameSpace)
		if returnType is not None:
			# Check for list: when the return type is a list, the function's type
    		# nests the list name with other arguments.
			if returnType.text is None:
				returnType = returnType.find("src:name", nameSpace)
    		# (1) Is void
			if returnType.text == "void":
                name = "class has void " + fncName.text + "() function"
				# Check whether attribute has been seen globally
                if name not in attributeList:
		            attributeList[name] = id_no
					id_no += 1

			# (2) Returns type ...
			else:
				retAttr = fncName.text + "() function returns type " + returnType.text
				# Check whether attribute has been seen globally
                if reAttr not in attributeList:
                    attributeList[name] = id_no
					id_no += 1

​
		# Has annotation
		hasAnnot = fnc.find("src:annotation", nameSpace)
		if hasAnnot is not None:
            name = fncName.text + "() function has annotation @" + (hasAnnot.find('src:name', nameSpace)).text
			# Check whether attribute has been seen globally
            if name not in attributeList:
                attributeList[name] = id_no
				id_no += 1



    return attributeList


def outputDatabase(root, allAttributes):
